
//WeakMap与Map的区别有两点。
//1、WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。

//2、WeakMap的键名所指向的对象，不计入垃圾回收机制。

/*

WeakMap的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。
 */
const e1 = document.getElementById('foo');
const e2 = document.getElementById('bar');
const arr = [
    [e1,'foo'],
    [e2,'bar']
]
/*
上面代码中，e1和e2是两个对象，我们通过arr数组对这两个对象添加一些文字说明。这就形成了arr对e1和e2的引用。
一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放e1和e2占用的内存。
 */
arr[0] = null; //不用的时候，必须手动删除
//上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。

/*
上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，
一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。
也就是说，上面的 DOM 节点对象的引用计数是1，而不是2。
这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。
总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。
 */

